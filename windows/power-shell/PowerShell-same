Get-Service seclogon
Start-Service seclogon
//Запуск от имени другого пользователя 
Start-Process -FilePath "powershell.exe" -Verb RunAsUser

//Установить набор компонентов администрирования AD
Get-WindowsCapability -Online|?{$_.name -like '*xps*'}|Add-WindowsCapability -Online -LimitAccess -Source "\\10.129.130.25\c$\drivers\en_windows_10_features_on_demand_part_1_version_1809_updated_sept_2018_x64_dvd_a68fa301"

Get-WindowsCapability -Online|?{$_.name -like '*Rsat.ActiveDirectory.DS-LDS.Tools~~~~0.0.1.0*'}|Add-WindowsCapability -Online -LimitAccess -Source "\\10.129.130.25\c$\drivers\en_windows_10_features_on_demand_part_1_version_1809_updated_sept_2018_x64_dvd_a68fa301"


$currentWU = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "UseWUServer" | select -ExpandProperty UseWUServer
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "UseWUServer" -Value 0
Restart-Service wuauserv
Get-WindowsCapability -Name RSAT* -Online | Add-WindowsCapability –Online
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "UseWUServer" -Value $currentWU
Restart-Service wuauserv

//PowerShell скрипт смены пароля в AD у всех пользователей. Меняет всем пароль в AD и ставит галку о смене при первом входе.

Import-Module ActiveDirectory

$users = Get-ADUser -Filter * -SearchBase "OU=Пользователи,DC=flammlin,DC=local"
foreach ($user in $users)
{
$password = ConvertTo-SecureString -String "Qwerty123" -AsPlainText –Force
Set-ADAccountPassword -Identity $user -NewPassword $password -Reset -PassThru | Set-ADuser -ChangePasswordAtLogon $True
}


//Узнать имя по SID
wmic useraccount where sid='S-1-5-21-2749816300-1181617901-2751356043-4187' get name
Get-ADUser -Identity S-1-5-21-2749816300-1181617901-2751356043-4187


//добавим правила в сетевой экран Из под PowerShell (с правами администратора)
New-NetFirewallRule -DisplayName 'Zabbix agent_inb' -Profile 'Any' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 10050
New-NetFirewallRule -DisplayName 'Zabbix agent_out' -Profile 'Any' -Direction Outbound -Action Allow -Protocol TCP -LocalPort 10050

//Отключить Defender
Set-NetFirewallProfile -Profile Domain, Public, Private -Enabled False

//Проверки домена

dcdiag /s:DC1.TCBDomen.trustcombank.ru
netdiag /fix
dcdiag /fix

//доменное имя (запись dns)
nslookup 10.129.135.205

//Отчет по доменной политики, запускать из папки куда нужно положить файл html с отчетом
gpresult.exe /H GPReport.html


Работа с файлами и папками PowerShell

Перечисление всех файлов и папок в папке

Все элементы можно получить непосредственно в папке с помощью Get-ChildItem. Для отображения скрытых и системных элементов добавьте необязательный параметр Force. Например, эта команда отображает прямое содержимое диска C:PowerShell.
Get-ChildItem -Path C:\ -Force


Команда перечисляет только непосредственно содержащиеся элементы, например команду dir в cmd.exe оболочке UNIX или ls в ней. Чтобы отобразить элементы в вложенной папке, необходимо указать параметр Recurse . Следующая команда выводит список всех элементов на C: диске:
Get-ChildItem -Path C:\ -Force -Recurse


Командлет Get-ChildItem позволяет отфильтровать элементы с помощью параметров Path, Filter, Include и Exclude, но обычно осуществляется лишь фильтрация по имени. Вы можете выполнять сложную фильтрацию на основе других свойств элементов с помощью Where-Object.
Следующая команда находит все исполняемые файлы в папке Program Files, которые были изменены после 1 октября 2005 года, и они не меньше 1 мегабайт или больше 10 мегабайт:
Get-ChildItem -Path $env:ProgramFiles -Recurse -Include *.exe |
    Where-Object -FilterScript {
        ($_.LastWriteTime -gt '2005-10-01') -and ($_.Length -ge 1mb) -and ($_.Length -le 10mb)
    }



Копирование файлов и папок

Копирование выполняется с помощью командлета Copy-Item. Следующая команда создает резервную копию скрипта профиля PowerShell:
if (Test-Path -Path $PROFILE) {
    Copy-Item -Path $PROFILE -Destination $($PROFILE -replace 'ps1$', 'bak')
}


Команда Test-Path проверка, существует ли скрипт профиля.

Если целевой файл уже существует, то попытка копирования завершается неудачей. Чтобы перезаписать имеющийся целевой файл, используйте параметр Force.
if (Test-Path -Path $PROFILE) {
    Copy-Item -Path $PROFILE -Destination $($PROFILE -replace 'ps1$', 'bak') -Force
}


Эта команда работает, даже если целевой объект доступен только для чтения.

Так же выполняется и копирование папок. Эта команда копирует папку C:\temp\test1 в новую папку C:\temp\DeleteMe рекурсивно.
Copy-Item C:\temp\test1 -Recurse C:\temp\DeleteMe


Можно также скопировать избранные элементы. Следующая команда копирует все .txt файлы, содержащиеся в любом месте в C:\dataC:\temp\text:
Copy-Item -Filter *.txt -Path c:\data -Recurse -Destination C:\temp\text
Вы по-прежнему можете выполнять собственные команды, такие как xcopy.exe и robocopy.exe копировать файлы.


Создание файлов и папок

Создание новых элементов работает одинаково для всех поставщиков PowerShell. Если поставщик PowerShell имеет несколько типов элементов, например поставщик FileSystem PowerShell различает каталоги и файлы, необходимо указать тип элемента.

Эта команда создает папку C:\temp\New Folder:
New-Item -Path 'C:\temp\New Folder' -ItemType Directory

Эта команда создает пустой файл C:\temp\New Folder\file.txt.
New-Item -Path 'C:\temp\New Folder\file.txt' -ItemType File


Удаление всех файлов и папок в папке

Удалить вложенные элементы можно с помощью командлета Remove-Item, однако он потребует подтверждения удаления, если элемент сам что-нибудь содержит. Например, если вы попытаелись удалить папку C:\temp\DeleteMe , содержащую другие элементы, PowerShell запрашивает подтверждение перед удалением папки:
Remove-Item -Path C:\temp\DeleteMe

Если вам не нужно запрашивать каждый содержащийся элемент, укажите параметр Recurse :
Remove-Item -Path C:\temp\DeleteMe -Recurse