
#Сравнение чисел

n1 -eq n2 Возвращает истинное значение, если n1 равно n2
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2
n1 -gt n2 Возвращает истинное значение, если n1 больше n2
n1 -le n2 Возвращает истинное значение, если n1меньше или равно n2
n1 -lt n2 Возвращает истинное значение, если n1 меньше n2
n1 -ne n2 Возвращает истинное значение, если n1не равно n2

[ $val1 -gt 5 ]

#Сравнение строк

str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны
str1 != str2 Возвращает истину, если строки не идентичны
str1 < str2 Возвращает истину, если str1меньше, чем str2
str1 > str2 Возвращает истину, если str1больше, чем str2
-n str1 Возвращает истину, если длина str1больше нуля
-z str1 Возвращает истину, если длина str1равна нулю

[ $val1 \> $val2 ] # знак больше, меньше нужно экранировать косой чертой

#Проверки файлов

-d file Проверяет, существует ли файл, и является ли он директорией
-e file Проверяет, существует ли файл
-f file Проверяет, существует ли файл, и является ли он файлом
-r file Проверяет, существует ли файл, и доступен ли он для чтения
-s file Проверяет, существует ли файл, и не является ли он пустым
-w file Проверяет, существует ли файл, и доступен ли он для записи
-x file Проверяет, существует ли файл, и является ли он исполняемым
file1 -nt file2 Проверяет, новее ли file1, чем file2
file1 -ot file2 Проверяет, старше ли file1, чем file2
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь
-G file Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя

Трюки терминала Bash

Полезные комбинации клавиш (хоткеи) и небольшие хитрости, которые сделают Вашу работу в Linux более эффективной.

Горячие клавиши Bash с Ctrl
Ctrl + n — то же самое, что и стрелка вниз.
Ctrl + p — то же самое, что и стрелка вверх.
Ctrl + r — поиск по предыдущим командам из истории команд (history). Продолжайте нажимать Ctrl + r, чтобы искать дальше. Ctrl + Shift + r — поиск в другую сторону.
Ctrl + s — остановить вывод в терминал.
Ctrl + q — восстановить вывод в терминал после Ctrl + s.
Ctrl + a — перейти к началу строки (аналог клавиши Home).
Ctrl + e — перейти к концу строки (аналог клавиши End).
Ctrl + d — если вы ввели что-то, то Ctrl + d удаляет символ под курсором. В противном случае означает конец ввода и завершает текущую сессию Bash.
Ctrl + k — удалить весь текст от курсора до конца строки.
Ctrl + x + backspace — удалить весь текст от начала строки до курсора.
Ctrl + t — переставить символ до курсора на символ под курсором. Нажмите Esc + t для перестановки двух слов до курсора.
Ctrl + w — удалить слово до курсора; затем Ctrl + y, чтобы вставить его.
Ctrl + u — удалить строку перед курсором; Ctrl + y для вставки его.
Ctrl + _ — отменить ввод.
Ctrl + l — очищает окно терминала. То же самое, что и clear.
Ctrl + x + Ctrl + e — запускает редактор, определённый в переменной $EDITOR, для ввода команды. Полезно для многострочных команд.

Изменить заглавные на строчные и наоборот
Esc + u — преобразовать буквы от курсора до конца строки в заглавные буквы.
Esc + l — преобразовать буквы от курсора до конца строки в нижний регистр.
Esc + c — заменить букву под курсором на заглавную.

Запустить предыдущую команду ещё раз
Запустить команду из истории по номеру (например, 53)
!53
!! — запуск последней команды.
sudo !! — запустить предыдущую команду с sudo.

Запускает последнюю команду и меняет какой-то параметр. Например, меняем "aaa" на "bbb":
# Последняя команда: echo 'aaa'
$ ^aaa^bbb

$ echo 'bbb'
bbb

Важно: предыдущая команда заменит только первое вхождение "aaa". Если вы хотите заменить все вхождения, используйте :&:
^aaa^bbb^:&
# или
!!:gs/aaa/bbb/

Запустить последнюю команду, которая начинается с...
Например, до этого в истории команд была команда cat filename:
!cat
# или
!c

— запускает cat filename ещё раз.

Указание файлов по шаблону в Bash
/etc/pa*wd → /etc/passwd — символ * означает "несколько любых символов".
/b?n/?at → /bin/cat — символ ? означает "один любой символ".
ls -l [a-z]* — вывести список файлов, содержащих только буквы латинского алфавита. В квадратных скобках [] перечисляются символы, которые будут искаться. А символ * после [] означает "хоть сколько раз".
ls {*.sh,*.py} — вывести все .sh и .py файлы. {} используется для группировки нескольких шаблонов по принципу "или".

Полезные переменные окружения Bash
Короткие переменные:
$0 — оболочка командной строки или путь до запускаемого файла.
$1, $2, $3, ... — аргументы запуска скрипта.
$# — число аргументов, переданных в скрипт из терминала.
$? — код завершения последней команды.
$- — текущие опции, установленные для оболочки.
$$ — идентификатор текущего процесса.
$! — идентификатор процесса, завершённого последним.

Более длинные, но тоже полезные переменные:
$DESKTOP_SESSION — текущий менеджер дисплеев.
$EDITOR — редактор текста по умолчанию.
$LANG — используемый системой язык.
$PATH — список директорий, в которых будут искаться исполняемые файлы.
$PWD — текущая директория.
$SHELL — текущая оболочка командной строки.
$USER — имя текущего пользователя.
$HOSTNAME — имя текущего хоста (компьютера).


Переменные в строке bash
echo os-$(uname) # os-Linux

Команды
break - выход из цикла for, while или until
continue - выполнение следующей итерации цикла for, while или until
echo - вывод аргументов, разделенных пробелами, на стандартное устройство вывода
exit - выход из оболочки
export - отмечает аргументы как переменные для передачи в дочерние процессы в среде
hash - запоминает полные имена путей команд, указанных в качестве аргументов, чтобы не искать их при следующем обращении
kill - посылает сигнал завершения процессу
pwd - выводит текущий рабочий каталог
read - читает строку из ввода оболочки и использует ее для присвоения значений указанным переменным.
return - заставляет функцию оболочки выйти с указанным значением
shift - перемещает позиционные параметры налево
test - вычисляет условное выражение
times - выводит имя пользователя и системное время, использованное оболочкой и ее потомками
trap - указывает команды, которые должны выполняться при получении оболочкой сигнала
unset - вызывает уничтожение переменных оболочки
wait - ждет выхода из дочернего процесса и сообщает выходное состояние.

Зарезервированные переменные
$DIRSTACK - содержимое вершины стека каталогов
$EDITOR - текстовый редактор по умолчанию
$EUID - Эффективный UID. Если вы использовали программу su для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя, в то время как...
$UID - ...содержит реальный идентификатор, который устанавливается только при логине.
$FUNCNAME - имя текущей функции в скрипте.
$GROUPS - массив групп к которым принадлежит текущий пользователь
$HOME - домашний каталог пользователя
$HOSTNAME - ваш hostname
$HOSTTYPE - архитектура машины.
$LC_CTYPE - внутренняя переменная, котороя определяет кодировку символов
$OLDPWD - прежний рабочий каталог
$OSTYPE - тип ОС
$PATH - путь поиска программ
$PPID - идентификатор родительского процесса
$SECONDS - время работы скрипта(в сек.)
$# - общее количество параметров переданных скрипту
$* - все аргументы переданыне скрипту(выводятся в строку)
$@ - тоже самое, что и предыдущий, но параметры выводятся в столбик
$! - PID последнего запущенного в фоне процесса
$$ - PID самого скрипта

Переменные и параметры скрипта
Приведу как пример небольшой пример, который мы разберем:

#!/bin/bash 

# указываем где у нас хранится bash-интерпретатор 
parametr1=$1 # присваиваем переменной parametr1 значение первого параметра скрипта
script_name=$0 #п рисваиваем переменной script_name значение имени скрипта

echo "Вы запустили скрипт с именем $script_name и параметром $parametr1" # команда echo выводит определенную строку, обращение к переменным осуществляется через $имя_переменной.

echo 'Вы запустили скрипт с именем $script_name и параметром $parametr1' # здесь мы видим другие кавычки, разница в том, что в одинарных кавычках не происходит подстановки переменных.

exit 0 #Выход с кодом 0 (удачное завершение работы скрипта)


Результат выполнения скрипта:
ite@ite-desktop:~$ ./test.sh qwerty
Вы запустили скрипт с именем ./test.sh и параметром qwerty
Вы запустили скрипт с именем $script_name и параметром $parametr1